# __Repo for studing jpa/hibernate features:__ [![Build Status](https://travis-ci.com/4atlanin/jpa_hibernate.svg?branch=master)](https://travis-ci.com/4atlanin/jpa_hibernate)

#### Инициализация БД
 - Если инициализируем базу данных с помощью хибернейта, и хотим выполнить на старте какие-то скрипты после инициализации, то нужно закинуть в ресурсы
  файл `data.sql`, пропертю выставить `spring.datasource.initialization-mode=always`(`spring.jpa.hibernate.ddl-auto` должен быть не `none`)
 - Если мы не хотим инициализации бд хибернейтом, а хотим своим скриптом: нужно закинуть в ресурсы
  файл `schema.sql`, пропертю выставить `spring.datasource.initialization-mode=always`(`spring.jpa.hibernate.ddl-auto` должен быть `none`);
 - schema.sql и data.sql неприменимы вместе
 
 Для того, чтобы выполнить инициализацию бд на старте приложения нужно в ресурсы положить файлик `schema.sql` и включить `spring.datasource.initialization-mode=always`. 
 Нужно помнить, что `schema.sql` не будет работать, если мы генерируем схему с помощбю хибернейта(`hibernate.ddl-auto` должен быть `none`).
 - Если мы генерируем схему приложения с помощью хибернейта, то мы можем выполнить какие-то sql скрипты после генерации. Для этого нужно в в ресурсы закинуть `data.sql`.
 Нужно помнить, что data.sql не работает
 
 PS. Можно запускать свои скрипты(`function.sql`) на старте примерно c таким конфигом:
 ```
 spring:
   jpa:
     hibernate.ddl-auto: update
  datasource:
     initialization-mode: always
     data:
       - 'classpath:sql/function.sql'
 ```
- если Хибер видит `import.sql` в руте класпаса, то он его выполнит после генерации схемы.
- если нужно указать много файлов, можно передать их списком в `hibernate.hbm2ddl.import_files` параметр.
- Можно расширить `AbstractAuxiliaryDatabaseObject` чтобы програмно управлять генерацией схемы.
- Больше ништяков можно прочитать в книжке, стр 248 - 249

 ##### Аттрибуты
 - @Temporal устарела. Применима только к старм Date.
 - @Transient 
 - На геттеры можно навешивать
- Аннотации бесмысленно вешать над setteraми
 ###### Access types
  - По умолчанию, JPA смотрит на поля, а не геттеры.(Аннотации почитать, если их нету то прост поля)
  - @AccessType может быть над классом, полем или геттером. Над классом самый низкий приоритет.
  - В такой комбинации будет работать геттер.(Те то что над геттером - важнее)
   ```
   @Entity
   @Table( name = "entity_attributes" )
   @Access( AccessType.FIELD )
   public class EntityAttributes
   {
       @Id
       private Integer id;
   
       @Column( name = "not_work" )
       @Access( AccessType.FIELD )
       private String accessTesticus;
   
       @Access( AccessType.PROPERTY )
       @Column( name = "accessTesticus" )
       public String getAccessTesticus()
       {
           return accessTesticulus;
       }
   }
   ```
####### Dirty Checking
- от аннотации `@Id` зависит то, как будет получен доступ к полям, через методы доступа(если `@Id` над методом) или напрямую к полям(если `@Id` над полем);
- хибер сравнивает состояния объектов по значению за исключением коллекций, коллекции сравниваются по идентичности. 
- т.к. у хибера по умолчанию доступ к полям напрямую, обычно проблем не возникает, 
    но если сделать доступ через методы get (`@Access( AccessType.PROPERTY` )), то при работе с коллекциями могут быть нежданчики(см `DirtyCheckingTest`)
    например если вернуть новую коллекцию со старыми сущностями, в базу улетят якобы изменения(). C не коллекциями такого нет.
#### Entity
###### Условия
 - Класс сущности должен быть помечен `@Entity` и иметь @Id(в случае простого PK).
 - Иметь public или protected конструктор без аргументов. 
    Он нужен для создания сущности при мапинге из результата селекта в Entity;
 - Быть классом(даже абстрактным), перечисления и интерфейсы не могут энтитями.
 - Быть классом верхнего уровня(не вложенным или внутренним).
 - Финальные классы не могут быть энтитями.
#### Жизненный цикл
![Жизненный цикл](http://1.bp.blogspot.com/_SgVI_8gfxSU/Szi5wJSyhSI/AAAAAAAAAvA/YG13rmVgd1Y/s1600/hibernate-persistent-states.png)
###### Transient (Временное состояние)
- Entity созданные через _new_.
- _PersistentUnitUtil#getIdentifier_ - позволяет узнать, является ли запись хранимой(вернёт id) или нет(вернёт null);
###### Persistent (Хранимое состояние)
- _Entity_ уже есть в БД или будет сохранён в конце транзакции. Имеет _ID_
- _EntityManager#contains_ - позволяет узнать, является ли запись хранимой или нет;
Состояние устанавливается методами:
    * `EntityManager#persist` - из _Transient_
    * `EntityManager#merge` - но! merge вернёт новый инстанс, старый останется в неизменённом состоянии. из _Transient_ и _Detached_
    * `Session#save` - из _Transient_
    * `Session#saveOrUpdate` - из _Transient_ и _Detached_
    * `Session#update` - из _Detached_
    * Любой метод достающий запись из БД.
###### Removed (Удалённое состояние)
- Запись будет удалена после коммита транзакции.
Состояние устанавливается методами:
    * `EntityManager#remove`
    * `Session#delete`
    * используя механизм `orphanRemoval`
###### Detached (Отсоединённое состояние) 
- Когда запись не привязана(отслеживается) к EntityManager(ом)
- _PersistentUnitUtil#getIdentifier_ вернёт id и сущность не является хранимой
Состояние устанавливается методами:
    * `EntityManager#detach`
    * `EntityManager#close`
    * `EntityManager#clear`
    * `Session#evict` 
#### Айдишники
 - `@EmbeddedId` лучше использовать, чем `@IdClass`. C `EmbeddedId`  нужно прописывать поля только 1 раз, т.е Вероятность ошибки меньше.
 Но `@IdClass` удобен, если нужно использовать в качестве Id-шника класс который мы не можем менять. 
 Несчитая использования в JPQL, они дают одинаковый результат.
- `@MapsId` возьмёт id из поля или энтити над которой он висит и засунет в PK Энтити. Может сувать также и в часть составного ПК.
- все классы использующиеся в качестве _ID_ обязаны имплементировать `Serializable`, т.к. они могут использоваться в качестве ключей в кеше второго уровня.
- _EntityManager#persist_ только присвоит _id_ сущности. !!Но, если генератор создаёт id при вставке, то _EntityManager#persist_ сделает _INSERT_
##### @ElementCollection
- Если храним мапу, то в созданной таблице PK будет составной. ПК главной таблицы + ключ Мапы. Тоже самое если храним мапу у которой значения это `@Embeddable`;
- А вот если использовать `@Embeddable` как ключ, то:
    - поля `@Embeddable` не могут быть _null_;
    - в `@Embeddable` должен быть переопределён _equals_ and _hashCode_;
    - не имеют смысла `@AttributOveride` и `@MapKeyColumn` над коллекцией;
- Если храним Set, то в созданной таблице PK будет составной. ПК главной таблицы + Знечение Set. Если в Set лежит `@Embeddable`, то все его поля попадут в PK
- `Collection = new ArrayList();` называется _контейнером(bag)_, делается через сурогатный ключь (используя `@CollectionId`).
Порядок не гарантирует в отличии от `List = new ArrayList();`. Посортировать с помощью `@SortComparator` или '`@SortNatural` неполучится
- Настройка таблицы для коллекций осуществляется аннотацией `@CollectionTable`.
- Если не указывается тип коллекции(_Set_ вместо _Set<String>_), то нужно сообщить эту информацию через `@ElementCollection(targetClass = String.class)`;
- Предыдущий пункт применим и к _Map_, плюс ещё нужно указать тип ключа через аннотацию `@MapKeyClass`;
- Чтобы персистить свою собственную коллекцию, нужно нужно заимплементить интерфейс `PersistentCollection`
- Вызов _clear()_ на коллеции `@ElementCollection` отправит 1 **DELETE**;
- В Колонках _Map_ для настройки value используются `@@Column`, а для key `@MapKeyColumn`.
- Если ключ в _Map_ это перечисление, нужно помечать коллекцию аннотацией `@MapKeyEnumerated`. Угадай для чего `@MapKeyTemporal`.
- Можно использовать `@ElementCollection` внутри `@Embeddable`, выглядит всё также как и из обычной энтити;
##### Embeddable
- Embeddable сущности можно сувать одна в одну,т.е. полем в Embeddable может быть другая Embeddable
- В книжке(Изучаем JavaEE 7, стр 189) пишут, что для Embedded сущностей лучше явно задавать тип доступа(@Access), чтобы внутри Embedded класса 
  всегда был тот, который нам нужен(например, если в наружном классе кто-то захочет его переопределить). Но я хз, как по мне лучше его не трогать совсем. 
- При генерации DDL Валидационные аннотации игнорируются. Баг HVAL-3.
- Если мы сохранили не null `@Embeddable`, но со всеми пустыми полями, то при получении записи из БД, `@Embeddable` поле будет null.
- Не обязательно ставить одновременно`@Embeddable` над классом и `@Embedded` над полем, важно хотябы одно.
- Можно наследовать `@Embeddable` от `@MappedSuperClass`, но при этом ссылка в Энтити всегда должна указывать на Кокретную реализацию `@Embeddable`, не `@MappedSuperClass`.
    Причина в том, что Hibernate не умеет полиморфно сохранять базовый не `@Embeddable` класс, так как нету признака различия между ними.
- Можно использовать `@ElementCollection` внутри `@Embeddable`, выглядит всё также как и из обычной энтити;
- `@Embeddable` могут определять однонаправленные связи, направленные к сущности.
### OrderBy
-  JPA `@OrderBy("name ASC")` - jpa добавит `order by locations1_.lob_name asc` в реквест и в коллекции будут лежать записи посортированные по этому признаку.
    Можно указывать и филды и колонки бд. Можно указывать несколько колонок - `@OrderBy("name DESC, id ASC")`.
- Хибернейтовский 
~~- `@OrderBy` из JPA не рабтает с `@ElementCollection`, в отличии от хибернейтовского аналога.~~  
!!!! Странное утверждени, в книге по хиберу(стр 186) пишут что работает, но только как _ASC_ и имя колонки не нужно указывать для простых типов. PS. Это всего лишь Поведение по умолчанию.
PPS. Проверил в  `testOrderWithElementCollection` и `testWithEmbeddableElementCollection`, всё ок с простыми и коллекциями, и коллекциями Embedded
- `@OrderColumn` применяется только над  `@OneToMany`, `@ManyToMany` or `@ElementCollection`. Самое первое значение = 0.
- Если применить `@OrderBy` и `@OrderColumn` одновременно, то `@OrderBy` работать не будет.(из доки для аннотации, не тестил)
- При использовании `@OrderColumn` записи будут отсортированы в порядке вставки. (Выглядит бесполезной хренью, или я не понял глубины мысли, 
    разве что, посортировал перед вставкой и сохраняешь в нужном тебе порядке, но опять же это не выглядит обратно совместимым...).
- `@OrderColumn` для каждой связи генерирет отдельную последовательность. 
- Если есть разрывы в последовальностях колонки порядка(0, 1, 3), то в _List_ запишется 4 элемента, вместо третьего будет _null_;
- При удалении записи, которая посортирована с помощью доп колонки, в базу улетит delete и, при необходисмости, несколько update, чтобы выровнять сортировочный индекс.
- Сортировка прямо в памяти производится с помощью аннотации `@SortComparator`, которая принимает класс реализующий `Comparator`.
- Или `@SortNatural`, тогда для сравнения будет вызываться `Comparable#compareTo`. Тип лежащий в коллекции должен обязательно имплементить этот интерфейс.
### Связи
 - `@JoinColumn` используется для настройки столбца FK
 - Если `fetchType` стоит LAZY, и мне нужен только Id связи, LazyInitializationException не бросится, т.к. не нужен запрос в базу. 
     Id связи уже есть внутри владеемой сущности.
 - `@JoinTable` **висит на cтороне владельца!!!**. 
- каскад _REMOVE_ заставит хибер загрузить все значения из например коллекции и к каждой применить _remove_. 
Нужно для того, чтобы энтити прошла весь жизненный цикл, темболее хибер хочет посмотреть, какие связи есть у удаляемых по каскаду энтитей.
И это не эффективно. Можно тогда написать свой квери, удаляющий сразу всех по ID. Или сделать зависимую энтитю встраиваемым компонентом `@Embeddable`.
- по спеке у `@PrimaryKeyJoinColumn` Lazy не работает с **optional = true**. Но можно обойти ограничение через модификацию байткода
- а вот Для связи по фк (@JoinColumn) всё будет ок, т.е. владелец связи имеет fk на зависимую таблицу, и точно чзнает о существовании энтити. Это позволяет создать прокси объект.
#### Однонаправленные
 - В однонаправленной владелец связи это тот, у кого лежит фк.
##### ManyToOne
- Самая простая связь;
- `@ManyToOne(optional = false)` тоже что и `@JoinColumn`  
- cascade в тут выглядит ненужным, т.к. _Many_ сторона не должна влиять на _One_ сторону.
##### OneToOne
- `@PrimaryJoinColumn` при использовании такой стратегии, владеющему объекту придётся вручную установить id(тотже что и у зависимого);
- `@OneToOne` не поддерживает Lazy при optional = false. Но можно обойти ограничение через модификацию байткода.
##### OneToMany
 - по умолчанию, @OneToMany создаёт таблицу связи, как в ManyToMany.
#### Двунаправленные
 - `mappedBy` находится на НЕ владеющей стороне связи.
 - `mappedBy` используется только в двунаправленной связи.
 - `mappedBy` не может находится на обеих концах двунаправленной связи.
 - Если в двунаправленной связи нету `mappedBy`, тоже как-то криво, Это будут 2 однонаправленных.
##### OneToOne
- В двунаправленной OneToOne `mappedBy` не создаёт доп колонки в таблице на которой он провисан. Он просто указывает, что аттрибут связи находится 
   в другой сущности. 
- Для связи с общим ПК LAZY загрузка будет работать только при `optional = false`, чтобы хиберу не пришлось обращаться к базе и не проверять, есть связь или нетуж;
##### @OneToMany
 - `mappedBy` не может находится в аннотации `@ManyToOne`.
 - лучшая коллекция для связи `@OneToMany` это **bag** (_Collection<Any> a = new ArrayList<>()_). По дефолту Хибер для коллекций использует ленивую загрузку, а
Bag не хранит порядок и не проверяет уникальность, поэтому при добавлении в такую коллекцию не инициируется загрузка данных.
- если использовать Bag в двунаправленой связи как в `OneToManyBagTest` можно лениво загружать коллекцию. Даже добавление в коллекцию новой записи не тригернёт загрузку.
- Хибер игнорирует повторяющиесе энтити в коллекции;
- `@ManyToOne` находится всегда на владеющей стороне, у неё нету аттрибута _mappedBy_
- можно сделать `@ManyToOne` [владеемой стороной:](https://www.baeldung.com/hibernate-one-to-many#3-cart-as-the-owning-side)
```
    @ManyToOne
    @JoinColumn(name = "cart_id", insertable = false, updatable = false)
    private CartOIO cart;
    --------------
    @OneToMany
    @JoinColumn(name = "cart_id") // we have to duplicate the physical information
    private Set<ItemsOIO> items;
```
- Из `@Embeddded` тоже можно делать однонаправленную связь(стр 230 - 231 книги)
##### @ManyToMany
- нужно явно указывать кто кем владеет с помощью аттрибута `mappedBy`.
- сторона помеченная `mappedBy` по факту доступна только для чтения, т.к. Хибернейт при сохранении анализирует противоположную сторону;
- для связи `@ManyToMany` бесмысленны(вредны) операции `CascadeType.ALL`, `CascadeType.REMOVE` и _orphanRemoval_. Т.к. по цепочке можно снести очень много, [хорошая статья на тему](https://thorben-janssen.com/avoid-cascadetype-delete-many-assocations/)
#### Каскады
- `CascadeType.PERSIST` при вызове метода `EntityManager#persist`
- `CascadeType.REMOVE` при вызове метода `EntityManager#remove`
- `CascadeType.DETACH` при вызове метода `EntityManager#detach`
- `CascadeType.MERGE` при вызове метода `EntityManager#merge`. Этот параметр вынуждает хибер игнорировать LAZY загрузку, т.е. если мержим энтитю с неинициализированой коллекцией то хибер потянет её из бд через JOIN.
- `CascadeType.REFRESH` при вызове метода `EntityManager#refresh`
- `CascadeType.REPLICATE` при вызове метода `Session#replicate` (он для копирования из одной БД в другую)
- `CascadeType.ALL` включает все способы каскадирования
- Persistence by reachability - любая энтитя становится хранимой когда приложение создаёт ссылку на неё из уже хранимого объекта. Хибер не поддерживает такого по дефолту. 
Чтобы включить нужно: в _orm.xml_ добавить _<cascade-persist/>_ (стр 373). После включения Хибер всем связям выставит каскад PERSIST по умолчанию.
## Наследование
- Если Энтитя наследует обычный POJO, то поля из пождика не будут персиститься.
- Чтобы персистить поля наследуемой POJO, нужно пометить поджу аннотацией `@MappedSuperClass`.
- Нельзя применять аннотации наследования к интерфейсам, кэп.
- Но можн замутить полиморфизм реализуя интерфейс.
#### Single Table
-  Если не использовать никаких доп аннотаций, будет использоваться стратегия `InheritanceType.SINGLE_TABLE`. Нужно прост унаследловать нужные энтити от базовой.
- `InheritanceType.SINGLE_TABLE` создаст таблицу в которой будут колонки для всех полей, всех классов иерархии + колонка дискриминатора(по дефолту с именем _DTYPE_, строкового типа и хранящая имя энтити).
- `@DiscriminatorColumn` настраивает колонку дискриминатора, по дефолту будет `DTYPE`.
- `@DiscriminatorValue` настраивает значение, по которому будут различаться Энтити в таблице, по дефолту будет имя класса.
###### Недостатки
1. Новые сущности - новые колонки в таблицу, и может понадобиться миграция для старых, перестройка индексов. 
2. Столбцы дочерних сущностей должны допускать null значения.
3. По дефолту(без аннотаций) используется подобие `Table Per Class`, но при полиморфном запросе будет N селектов в базу, где N - к-во энтитей в иерархии.
####  Joined
- Нужно использовать `@Inheritance`, чтобы поменять стратегию наследования.
- На каждый класс иерархии будет своя таблица. Общие аттрибуты будут в таблице базовой сущности. Аттрибуты дочерних сущностей в своих собственных.
- Колонка дискриминатора будет находится в базовой таблице.
- При поиске по базовому классу используется `LEFT JOIN`, При поиске бо расширенному классу используется `INNER JOIN`
######  Недостатки
1. Чем глубже иерархия, тем тем больще таблиц будет джойниться, что снижает производительность.
2. Тоже самое для запросов, которые захватывают всю иерархию классов, производительнось тем ниче, чем иерархия шире.
#### Table Per Class
- Нужно использовать `@Inheritance`, чтобы поменять стратегию наследования.
- На каждый класс иерархии будет своя таблица. Каждая таблица будет содержать аттрибуты базовой(-ых) сущности(-ей) + аттрибуты самой сущности.
- Не нужна колонка дискриминатора
- Если базовая Энтити абстарктный класс, то ему не нужна будет доп таблица для хранения записей.
###### Достатки
- нету джойнов при запросе к конкретной сущности.
######  Недостатки
1. Чем глубже иерархия, тем тем больще таблиц будет джойниться, что снижает производительность.
2. Тоже самое для запросов, которые захватывают всю иерархию классов, производительнось тем ниже, чем иерархия шире.
3. JPA 2.1 не требует поддержки этой стратегии.
4. Запросы к таблицам подклассов будут через UNION.
## Переопределение аттрибутов энтити
#### Переопределение в @Embedded классах
- Для переопределения аттрибутов в _@Embedded_ классе, нужно над полем встраимываемого типа вешать аннотацию `@AttributeOverride(s)`.
- Для переопределения таблицы или столбца отображения в _@Embedded_ классе, нужно над полем встраимываемого типа вешать аннотацию `@AssociationOverride`.
так нельзя поменять стратегию отображения, только её настройки.
- при вложенных `@Embedded`, можно ставить `@AttributeOverride` на самом последнем уровне и обращаться ко внутренним `@Embedded` полям через точку.
 В других местах(над классом) она работать не будет для @Embedded.
#### Переопределение аттрибутов при наследовании
- с помощью `@AttributeOverride` можно переопределять настройки колонки из базового класса 
- `@AttributeOverride` затирает любые JPA/Hibernate(но не валидационные) аннотации над переопределяемыми полями. 
## EntityManager
- Все EntityManager произведённые одной EntityManagerFactory будут иметь одиаковую конфигурацию
- Persistence Context == First Level Cache.
- Каждый EntityManager имеет свой Persistence Context.
- У Заинжекченого Спрингом EntityManager, транзакции тоже управляются спригом. Т.е. для этого EM нельзя создавать ручные транзакции.
Я про _entityManager.getTransaction().commit();_ , C _TransactionTemplate_ всё будет норм, т.к. этими транзакциями управляет спринг.
- EntityManager#persist - ложит энтитю в Persistence Context, записана она будет при коммите транзакции
- _find_ вернёт null если не найдёт запись в бд.
- _getReference_ не подаст виду, если не найдёт записи в бд. Кинет _EntityNotFoundException_ при обращении к любому не айди полю обьекта.
вызов getId на респонсе с несуществующей энтитей вернёт id который передали в метод.
- после _merge_ изменения в сущности не отслеживаются Манагером. Т.е. после _merge_, мы меняем энтитю внутри транзакции и эти изменения не попадают в бд при коммите.
#### Запросы
- с помощью оператора NEW возможно засетать результат JPQL запроса в DTO см. `JPQLTest#testNewInJPQL`
Бывают 
1. Динамические - те которые простая строка. В строку можно собирать по кускам, поэтому они и называются динамическими.
 Строку передают в `EntityManager#createQuery`
2. Именованные - неизменяемая строка. Задаются над энтитей с помощью аннотации `@NamedQuery`
- Хорошая практика добавлять имя Entity в название запроса **Entity.findAll** 
- Хорошая практика делать имена кверей константами, меньше вероятность опечаток и прочей херни
3. Criteria API
- Criteria API поддерживает все, что может сделать JPQL, но с использованием основанного на объектах синтаксиса.
4. Native запросы - могут быть именованными
5. Хранимые процедуры - могут быть именованными
#### orphanRemoval
- Для связи _OneToOne_, при установке связи в _null_ будет удалена владеемая сущность.
- orphanRemoval тоже что и каскад + удаление владеемых сущносте нпри разрыве связи в бд.
### Second Level Cache
- по дефолту включён, но т.к. нету провайдера используется `NoCachingRegionFactory` т.е. обращения к кэшу игнорятся.
- для использования нужно подрубить `hibernate-jcache` + провайдер кэша, например `ehcache`, и добавить соответствующие проперти в `application.yaml`
- hibernate  игнорирует аннотацию `@Cacheable`, совсем. Он смотрит на @Cached
- перед загрузкой Entity генерируется `LoadEevent`, `DefaultLoadEventListener` перехватывает и хэндлит его: 
     - Если искомое есть в кэше сесси и оно консистентно и не удалено, то берём оттуда;
     - Если искомое есть в кэше второго уровня, то берём из второго кэша.
     - Иначе делаем запрос в базку данных.
### Transactions
- Транзакции в бд должны быть короткими, т.к. открытые транзакции потребляют ресурсы бд, темболее там богут быть блокировки которые провисят всё время транзакции;
- Транзакции только на чтение открываются быстрее? Кратко - нет в 99%, нужно на конкретной бд тестить, Стр 303;
- В OLTP время выполнения транзакции должно быть минимальным;
- Исключения возбуждаемые хибернейтом фатальны, т.е. после исключения с таким EntityManager запрещено работать. 
Но есть исключения из них(_NoResultException_, _NonUniqueResultException_, _QueryTimeoutException_, _LockTimeoutException_);
- Hibernate никогда ничего не блокирует в памяти, т.к. это менее эффективно;
#### ACID - atomicity, consistency, isolation, durability или атомарность, согласованость, изолированость, долговечность(стойкость)
- atomicity - все операции в рамках одной транзакции выполняются как одно целое;
- consistency - каждая успешная транзакция фиксирует только допустимые результаты;
- isolation - транзакция не должна быть видима другим транзакциям и они не должны никак влиять друг на друга. В реальности всё что ниже _Serializable_ нарушает этот принцип;
- durability - даже если будет сбой, все зафиксированные изменения должны сохраниться;
#### Проблемы транзакционности
- lost update(потерянное изменение) - когда две транзакции меняют что-то, а потом последняя откатывается. Или 2 транзакции начавшись одновременно, вторая перетирает результат первой;
- dirty read(грязное чтение) -  чтение незафиксированных данных;
- unrepeatable read(неповторяющееся чтение) - 2 чтения в рамках одной транзакции дают 2 разных результата; 
Особый случай, когда 2 параллельных транзакции прочитали данные и потом начали менять, и последняя перетрёт предыдущую;
- phantom read(фантомное чтение) - 2 разных чтения дают больше или меньше записей;
#### Уровни изоляции
- Read uncommitted - позволяет избежать _lost update_. Блокировка накладывается на операцию изменения. На _SELECT_ блокировка не накладывается.
- Read committed - позволяет избежать _dirty read_. Есть 2 способа реализации:
    - пишущая транзакция блокирует изменяемую строчку для чтения до своего завершения, а читающая транзакция освобождает данные сразу после завершения _SELECT_;
    - MVCC, пишущая транзакция работает с копией строчки, а читающие смотрят на оригинал. Тут выше скорость, т.к. нету блокировок, но в тоже время и ест больше памяти, 
    а также при параллельном апдейте могут потерятся изменения(тут по идее должна быть ошибка выведена);
- Repeatable read - Читающая транзакция не видит изменения данных, которые были ею прочитаны. Читающая транзакция блокирует строчки, которые она читает до её окончания. 
Однако другие транзакции могут вставлять строки между чтениями, т.е. будет фантомное чтение.
- Serializable - транзакции полностью изолированы друг от друга. Эмитируется последовательное выполнение. Лочится вся таблица в бд;
##### Выбор уровня изоляции
- Если в прилаге много потоков(коннектов к бд), высокий уровень повредит производительности, а недостаточный может спрятать трудновоспроизводимые ошибки, которые могут появиться только под нагрузкой;
- никогда не юзайте _Read uncommitted_, т.к откат одной транзакции повлияет на все остальные, например прочитали из транзакции которая откатилась, и потом коммитнули откаченные данные;
- лучше не юзать _Serializable_, т.к. оно самое медленное, а для редких ситуации лучше юзать пессимистическую блокировку;
### Locks
- хибер будет лочить строки в таблицах супер классов и подклассов;
- соответствующие записи в `@SecondaryTable` также будут блокироваться;
- связь между 2мя энтитями тоже будет заблокирована, но только связь, т.е. ID;
- Монопольные (exclusive) блокировки могут вызывать _deadlock_;
- чтобы уменьшить вероятность взаимоблокировки, можно установить порядок выполнения операций _UPDATE_ с помошью флага `hibernate.order_updates`. Хибер будет сортировать апдейты по Id.
#### Pessimistic Lock
- Пессимистически блокировки в хибере длятся столько же сколько и сама транзакция;
- `javax.persistence.lock.timeout` позволяет определить время ожидания получения блокировки;
#### Optimistic Lock
- использовать, в случае с малым уровнем конкуренции транзакции. Блокировка на уровне приложения, т.е. в БД ничего не блокируется.
- поле с `@Version` обязательно, иначе `HibernateException: [OPTIMISTIC_FORCE_INCREMENT] not supported for non-versioned entities`
- если вручную меняем занчение колонки `@Version`, хибернейт всё равно отрабатывает корректно. Он не смотрит на изменённое значение.
- для `@Version` не должно быть сеттера, хибер сам инкрементит счётчик(он должен быть целочисленным);
- `@Version` не инкрементится, если изменение произошло в `@OneToMany` и `@ManyToMany` настроенных только на чтение и с аттибутом _mappedBy_;
- чтобы номер версии не увеличивался при изменении конкретного поля, его можно пометить аннотацией `@OptimisticLock(excluded = true)`;
- Хибер может проверять версии с помощью поля со временем, но это не безопасно. т.к. точность определения времени в JVM недостаточна.
`@Type(type="dbtypestamp")` заставляет использовать время БД сервера, но тут будут доп запросы к бд, что не ОК;
- Можно организовать оптимистическую блокировку без доп колонок, нужна аннотация `@OptimisticLocking` и `@DinamicUpdate`, смысл в том, что в начале хибер запомнит исходное состояни
записи, а потом перед коммитом он сделает апдейт с условием `WHERE` в котором будут все колонки и их значения до изменения. Если запись менялась, к-во обновлённых записей будет 0, тогда 
хибер это увидит и кинет исключение. Можно заюзать `OptimisticLockType.DIRTY`- хибер увидит конфликт, только если параллельные транзакции изменят одно и тоже поле.
- Оптимистическая блокировка без доп колонки не ок в случае слиянй и detached состояниями, т.к. неизвестны начальные значения полей.
##### LockMode
- `LockModeType.OPTIMISTIC` - значение `@Version` инкрементится на 1 при каждом изменении записи в бд.
- `LockModeType.OPTIMISTIC` - cравнение версий выполняется только при модификации записи в текущей транзакции. Если мы просто прочитали, потом кто-то в соседней транзакции поменял запись, мы про это не узнаем при простом чтении
- `LockModeType.OPTIMISTIC_FORCE_INCREMENT` - версия инкрементится 1 раз после чтения, и ещё 1 раз если запись была модифицированна в этой транзакции.
- `LockModeType.OPTIMISTIC_FORCE_INCREMENT` - сравнение версий выполняется в конце транзакции. даже если энтитя не модифицировалась в ней.
- `LockModeType.PESSIMISTIC_READ` - гарантирует изоляцию _Repeatable Read_, в _MySQL_ превращается в `LOCK IN SHARE MODE`;
- `LockModeType.PESSIMISTIC_WRITE` - гарантирует изоляцию _Serializable_. Со строчками будет только последовательная работа,  в _MySQL_ превращается в `FOR UPDATE`;
 Т.е. если прочитали энтитю, а потом её в этот момент модифицировали в другой транзакции, то при закрытии первой транзакции будет `OptimisticLockException` 
### Преобразование типов при сохранении
#### Basic Type
- _BasicType_ имеется ввиду, что мапится в одну колонку. Пока не вижу причин зачем он ещё может пригодиться.
#### User Type
- По сути маппинг в несколько колонок, но опять же не актуально. Можно заранее создать @Embeddable с нужными колонками.
#### Attribute converter
- Не работает с `@Enumerated` и `@Temporal`
#### Ограничения SQL
- ограничения домена(т.е. по типу);
- ограничения столбца(NOT_NULL or custom constraints defined with `Check` keyword)
- ограничения таблицы(UNIQUE или кастомные ограничения между несколькими колонками)
- ограничения БД(FK, FK может нарушаться если стоит _ON DELETE_ or _ON UPDATE_)
### EntityManager
- Получить конкретную реализацию _EM_ можно так: `EntityManager#unwrap`;
- С помощью `PersistenceUnitUtil` можно определить загрузилась Entity или нет(существует в качестве прокси объекта).
- _EntityManager_ выступает в роли кеша первого уровня;
- Кэш первого уровня никогда не уменьшается;
- Последовательные вызовы `EntityManager#find` для одного и тогоже _EntityManager_ вернут одинаковый результат.
- Кеш первого уровня гарантирует:
    * Уровень хранения не подвержен переполнению стека из-за циклических ссылок;
    * В конце транзакции не может существовать несколько конфликтующих представлений одной и той же сущности.
- _EntityManager_ не извлекает соединения _JDBC_ из пула пока не нужно будет выполнить _SQL_ запрос, т.е. можно создать и закрыть _EntityManager_ без единого запроса в БД;
- хороший тон помещать вызов _EntityManager#close_ в блок _finally_
- _EntityManager#persist_ только присвоит _id_ сущности. !!Но, если генератор создаёт id при вставке, то _EntityManager#persist_ сделает _INSERT_
- Перед персистом желательно полностью инициализировать сущность, Прикол в том, что хибер может попытаться сразу же сохранить сущность и если потом досетывать поля, то произойдёт дополнительный _UPDATE_.
Или же может быть _ConstraintViolationException_ из-за непроинициализированных полей.
- `EntityManager#find` всегда инициализирует нормальный объект, не прокси.
- `EntityManager#getReference` вернёт прокси если записи нету в кеше, или норм объект если он в кеше есть;
- Если вызвать `EntityManager#remove` для _Proxy_ объекта, хибер сделает SELECT в БД для загрузки полноценного объекта. Нужно для того, чтобы сущность прошла через весь жизненный цикл, чтобы повызывались всякие callback методы;
- `EntityManager#refresh` загрузит из бд и перетрёт в памяти все хранимые сущности. Если записи в бд больше нету, _refresh_ кинет `EntityNotFoundException`. Полезно, если пользователь отменил введённые данные или типа того;
- `EntityManager#merge` - возьмёт из кэша, а если там нету, загрузит из бд и намержит поверх поля из detached объекта и вернёт новыую Энтити;
- Если экземпляр временный (без Id) передать `EntityManager#merge`, сосздасться пустой объект и на нового помержится временный, созданный метод будет в хранимом состоянии;
- Можно юзать _EntityManager_ вне транзакции для чтения данных(режим автоматического подтверждения). Но Тогда Контекст будет в разсинхронизированном состоянии, т.е. хибер не будет выталкивать изменения даже при рукописном JPQL Query, он прочитает старые значения из кеша. стр 328;
- режим автоматического подтверждения полезен для подготовки всех изменений перед транзакцией. Можно сделать _persist_ вне транзакции чтобы получить ID(кроме случаев когда id генерируется при **INSERT**)
насохранять всяких полей, а потом присоеденить `EntityManager` к транзакции и закоммитить её. Тоже можно провернуть и для _merge_ или _remove_.
### Session
- `Session#replicate` позволяет копипастить данные из одно бд в другую. Управляется с помощью `ReplicationMode`;
- `ReplicationMode` бывает:
    * _IGNORE_ - не копипастить, если в бд уже есть такая запись;
    * _OWERWRITE_ - перетереть существующую запись;
    * _EXCEPTION_ - кинет исключение если в БД есть уже такая запись;
    * _LATEST_VERSION_ - перезаписать, если в бд старая версия. Работает только с оптимистически управлением конкурентным доступом;
- `Session#setDefaultReadOnly` позволяет перевести _Persistence Context_  в режим только для чтения, что отключит _Dirty Checking_ который не будет дублировать информацию, также хибер не будет сохранять изменения в БД;
- `Session#setReadOnly` переводит в режим для чтения отдельную сущность(вроде для _org.hibernate.Query_ такое тоже может быть);
- `Session#saveOrUpdate` в отличии от _merge_, в хранимое состояние переводится переданный экземпляр;
### Dirty Checking 
- можно кастомизировать реализовав `CustomEntityDirtinessStrategy` и зарегистрировав новый класс через пропертю `hibernate.entity_dirtiness_strategy`;
- или заимплементить интерфейс `org.hibernate.Interceptor`, метод `findDirty`;
### Ленивая загрузка
- чтобы лениво загружать _BLOB_ нужно юзать или _java.sql.BLOB_, или перехват вызовов;
- В отличии от _FetchType.LAZY_, _FetchType.EAGER_ - это требование, т.е хибер не сможет лениво загрузить такую коллекцию;
- `join fetch` позволяет форсить загрузку ленивых полей в JPQL и Criteria API.
- `left join fetch` аналогичная хрень для коллекций.
#### n + 1 проблема
- когда у нас есть список хрени, и мы в цикле по этому списку начинаем теребонькать другие ленивые связи. Получается что на каждая запись из списка, генерит ещё +1 запрос в базу;
- первое решение, это загрузка батчами, например по 10 штук; Размер батча можно указать c помощью `@BatchSize(size = 10)` над энтитей, или над коллекцией, тогда хибер загрузит коллекции для братских энтити; стр 353
- второе`@Fetch(FetchMode.SUBSELECT)` над связью, хибер будет коллекции загружать с помощью подзапросов. Не будет работать, если мы лениво загрузили основной обжект, а потом детачнули его и присоеденили к другому персистенс контексту;
#### проблема декартова произведения 
- появляется, когда 1 запросом EAGER загружают сразу несколько коллекций; Т.е. если у айтема 50 ставок и 5 картинок, то селект в базу вернёт 250 записей, большая часть инфы в которых не нужна;
Так получается, так как таблицы в запросе соединяются через JOIN и получается декартово произведение всех значений; Хибер их конечно потом выкинет, но ненужные данные уже были переданы по сети и тп;
- решение 1: `@Fetch(FetchMode.SELECT)`, хибер будет тащить зависимые записи дополнительными запросами в базу;
#### Загрузка батчами
- `hibernate.default_batch_fetch_size` глобальный параметр, а `@BatchSize(size = 10)` локальный, переопределяющий глобальный;
- `hibernate.batch_fetch_style`, 
    - значени **LEGACY** дефолтное, создаст несколько запросов. 
    - PADDED - один запрос, если нужно загрузить меньше элементов, вакантные места будут заполнены дубликатами.
    - DYNAMIC - на лету будет генерить SQL по количеству объектов в коллекции;
- при загрузке батчами будет использоваться _SELECT ... WHERE ... IN_;
- для батча например 1000 хибер сгенерирует зарпосы с количеством параметров от 1 до 10 и дальше по степеням двойки, 16, 32, 64, 128, 256, 512. В итоге хибернейт будет выполнять 6 запросов в базу, на 512, 256, 128, 64, 32 и 8 записей в батче;
- размер батча очень сильно влияет на потребление памяти: батч в 32 элемента есть дополнительно 62МБ, а батч в 1000 уже 156МБ примерно, как я понимаю память тратится на хранение кверей или типа того.
#### Профили извлечения
- это глобальные метаданные описывающие как нужно доставать связи из базы
```
@FetchProfiles({
    @FetchProfile( name = "profileName",
        fetchOverrides = @FetchProfile.FetchOverride(
            entity = SomeEntity.class,               // для какой энтити
            association = 'seller',                  // к какому полю иил коллекции
            mode = FetchMode.JOIN                    // режим загрузки, рагьше был доступен только JOIN, сейчас ХЗ
            ))
})

```
- для одной энтити можно применять разные профили в разных запросах;
#### Графы сущностей (с. 363)
```
@NamedEntityGraphs({
    @NamedEntityGraph(
        name = "ItemSeller",            // название графа, по дефолту имя Энтити над которой стоит аннотация
        attributeNotes = {
        @NamedAttributeNode("seller")   // атрибут котороый вытащить при запросе
        }
    )
})
```
- hint `javax.persistence.fetchgraph` должен вытянуть только те связи, которые указаны в графе(все атрибуты перечисленные в _EntityGraph_ меняют fetchType на _EAGER_, все остальные на _LAZY_).  Т.е. даже _EAGER_ не указаные в графе должны игнорится, но это в JPA !!! 
!!!В хибернейте _EAGER_ тоже будут доставаться. [тут написано](https://www.baeldung.com/jpa-entity-graph#creating-entity-graph-2)
- hint `javax.persistence.loadgrap` доставать всё что _EAGER_ и то что в графе. ( все атрибуты перечисленные в EntityGraph меняют fetchType на _EAGER_, все остальные сохраняют свой _fetchType_ (то есть если у атрибута, не указанного в _EntityGraph_, _fetchType_ был _EAGER_, то он и останется _EAGER_))
#### Прокси объекты
- Прокси объект, экземпляр класса хранящий только id, чтобы всё работало, оборачиваемый класс должен иметь _public_ или _protected_ дефолтный конструктор.
- любой метод не помеченой аннотацией @Id будет тригерить инициализацию прокси;
- `HibernateProxyHelper.getClassWithoutInicializationProxy` позволяет получить тип(класс) прокси;
- `PersistenceUtil.isLoaded` позволяет проверить, является ли объект прокси или нет, также есть версия с параметром имени поля в сущности, чтобы проверить поле внутри энтити;
- `PersistenceUtil` может работать вне персистенс  контекста;
- Для `@OneToOne` с общим ПК, _LAZY_ загрузка будет работать только при `optional = false`, чтобы хиберу не пришлось обращаться к базе и не проверять, есть связь или нету;
- ленивая загрузка не только для зашрузки. с помощью _getReference_ можно получить прокси и этот прокси просетать в связь новой энтити.  В итоге будет только 1 **INSERT**. стр 338.
- ленивая загрузка коллекций происходит благодаря специальным обёрткам коллекций. _PersistenceSet_ вместо _HashSet_ и тд; Эти спец коллекции могут обнаруживать обращение к ним и сразу загружать данные.
- `@LazyCollection (LazyCollectionOption.EXTRA)` позволяет выполнять некоторые операции с коллекцией которые не вызовут её инициализации. Т.е. для каждой операции в бд будет отдельный запрос.
Например можно узнать размер коллекции, или взять конкретный элемент по индексу, проерить естьли ключ в мапе и тд;
- `@Proxy(lazy = false)` отключает генерацию прокси класов. Т.е. даже _getReference_ вернёт целую энтитю;
##### Минусы Proxy
- если полиморфные ассоциации проверяются через _instanceof_, могут быть проблемы;
- внутри equals и hashCode обращения к полям должно быть через методы, чтобы прокси инициализировалось;
- отложеная загрузка не может применятся к полям простых или встраиваемых типов, только связей;
#### Перехват вызовов
- реализуется за счёт доп кода вокруг геттеров и полей ???
- нужн отключить генерацию прокси `@Proxy(lazy = false)`над энтитей и `@LazyToOne(LazyToOneOperation.NO_PROXY)` над связью. **А ещё нужно как-то включить оптимизатор байткода, хз как**;
- хибернейт лениво загрузит все поля, а не только то которое помечено ленивым;
- в книге пишут что не смогли запустить оптимизатор для 5-го хибернейта; стр 344
- даже с перехватом, хибер будет юзать свои собственные обёртки для колекций, нужно чтобы хибер мог видеть, что добавляется или удаляется из коллекции; эти коллекции нельзя отключить;
### Работа с событиями
#### EntityListeners and Callback Methods
##### Callback Methods
- все @Pre- выполняются перед соответствующей операцией, но есть исключения. Если энтитя уже приатачена к контексту, то merge не вызовет `@PreUpdate` и `@PostUpdate`. Похожая ситуация и с `EntityManager#find`.
- все @Post(кроме @PostLoad) выполняются при коммите транзакции или сбросе(flush) изменений.
- `@PostLoad`  работет сразу после загрузки энтити.
- callback метод не может быть `final` или `static`.
- на callback метод можно несколько аннотации @Pre, @Post вешать.
- callback метод не должен генерировать проверяемые исключения
- для класса не можеты быть несколько одинаковых анноитаций(даже над разными методами)
- callback метод суперкласса вызывается раньше callback метода в дочернем классе.
- при каскадировании событий, вызовы callback методов тоже каскадируются.
#### #EntityListeners
- Сюда нельзя внедрить и использовать `EntityManager`
- Должен иметь конструктор без параметров
- подключается аннотацией `@EntityListeners` которая принимает массив лисенеров и вызывает их в порядке перечисления
- Методы лисенеров вызываются раньше чем калбэки на энтити или на её суперклассе.
- лисенер и callback метод могут содержать одинаковые @Pre и @Post аннотации.
- лисенер суперкласса вызывается чем лисенер подкласса.
- `@ExcludeSuperclassListeners` используется для запрета наследования лисенеров от суперкласса. Т.е объявленные в суперклассе, действовать не будут;
- `@ExcludeDefaultListeners` отрубает дефолтные лисенеры. **TODO** Видел объявление дефолтных только в XMLе.
#### Interceptors
- имплементится с помощью расширения `EmptyInterceptor` стр 380 - 381
- внутри интерцептора нельзя использовать оригинальный `Persistence Context`, но можно создать его ограниченную копию через метод `Session#sessionWithOptions`;
- перехватчик подключается через параметр `hibernate.ejb.interceptor`, где ему указывают класс реализующий _Interceptor_;
- `Interceptor` должен быть потокобезопаным, т.к. он шарится между потоками;
- Это более гибкая функциональность которая позволяет получить больше контекстной информации при событии;
#### Event Listeners
- Каждый метод `EntityManager` генерирует какое-то событие;
- Для перехвата события, нужно имплементировать соответствующий интерфейс, например `DefaultLoadEventListener`;
- Listener это синглтон, т.е. должне быть написан в потокобезопасном стиле;
### Filters
- определяется фильтр аннотацией `@FilterDef`
```
@FilterDef(
    name = "filterName",
 // defaultCondition = "...",         можно настроить поведение фильтра по умолчанию
    parameters = {@ParamDef(name = "parameterName", type = "int")}
)
```
- применяется фильтр, аннотацией `@Filter` над Entity или связью
```
@Filter(
    name = "filterName",
    condition = ":parameterName >= (" +    // sql на стороне БД, должен возвращать true 
    "select u.rank from users u" + 
    "where u.id = seller_ID"
```
 где _parameterName_ может задаваться в `Session#enableFilter`
 - можно применить фильтр к коллекции(работают для _@XXXToMany_, для _@XXXToOne_)
```
@Entity
public class Lalka {
    @OneToMany(mappedBy="category")
    @Filter(name="limitByUserRank",
            condition=":currentUserRank >=(" +
            "select u.RANK from USERS u " + 
            "where u.ID = SELLER_ID)")
    protected Set<Item> items = new HashSet<Item>();
}
```
 - Хибернейт не применяет фильтрации к операторам извлечения по ID(`типа em.find(Class.class, ID)`), т.к. фильтр это кусок SQL запроса, а поиск по ID может выполнятся в кеше первого уровня;
 - Хибернейт не применяет фильтрации к связи `@ManyToOne` и `@OneToOne`, т.к. меняется множественность даже при наличии связи может вернуться _null_;
### Запросы
- Нет ничего плохого в использовании SQL в нетривиальных случаях;
- Можно связывать параметры по именам(_:parameterName_) и позициям(_?1_), но не одновременно в одном запросе;
- Запросы с постраничной выборкой работат на уровне SQL строк результата, т.е. **limit 10** в результирующем запросе необязательно вернёт 10 энтитей;
- При работе с курсором важно понимать, что JDBC driver может не поддерживать работу с курсором и все данные загрузятся в память;
- `TypedQuery#getSingleResult` кидает исключения в отсутствии хотябы одного, или при неуникальном результате;
- Прокрутка с помощью курсоров не работает вместе с динамическим извлечением(`join fetch`), scroll() выкинет исключение;
- Обход с помощью итератора, при вызове `query.iterate()` хибер сходит в базу и достанет все нужные id, а дальше будет делать запрос по id в бд на каждый вызов `next()`;
- В выражении LIKE можно использовать нижнее подчёркивание(_), оно соответствует любому символу в этой позиции;
#### JPQL
- Между HQL/JPQL разницы почти нету. Оба типа запросов разбираются одним и тем же  парсером;
- _SELECT_ требует наличие псевдонима: `SELECT i FROM Item i`;
- Псевдонимы не чувствительны к регистру;
- Класс в запросе _SELECT FROM_ не обязан быть энтити, там может быть любой класс или интерфейс(эти только в хибере, JPA не описывает такую возможность): `SELECT o FROM Object o` - потянет из бд вообще взе записи из всех таблиц. Можно перечислить классы которые нужно доставать стр 428;
- определены дополнительные методы для коллекций в HQL запросах: _size(), entry(), key(), value()_;
- любая неизвестная Хибернейту функция встреченая в _WHERE_ части, передаётся напрямую в БД в виде вызова SQL. В JPA так нельзя, там нужно использовать _function()_ стр 437;
- любая функция встреченая в проекции должна быть известна Хибернейту(cnh 445) и вызываться через _function()_; 
- можно указать хиберу, куда сувать null значения при упорядочивании, `ORDER BY ... NULL FIRST | LAST`, или пропертёй `hibernate.order_by.default_ordering`;
- Проекция сущностей: `SELECT i, b FROM Item i, Bid b` вернёт `List<Object[]>` где первый элемент массива будет Item, а второй Bid. Замечу, что запрос вернёт декартово произведение, что нафиг нужно;
- при динамическом создании сущностей(через new в JPQL), сущность будет находится во временном или в отсоединённом состоянии(зависит от id), а не в хранимом; 
- count(distinct i.name) удаляет дубликаты;
- В JPA можно указывать в группировке псевдонимы сущностей, но хибер такого не позволяет из-за чего будет несоответствие _SELECT_ и _GROUP BY_ части, поэтому в хибернейте нужно перечислить все поля для _GROUP BY_:
```
select i, avg(b.amount)
    from Bid b join b.item i
    group by i.id, i.name, i.createdOn, ...;
```
##### Соединения в JPA
###### Неявные соединения
тут будет неявный JOIN из-за обращения по связи b.item
```
    SELECT b FROM Bid b where b.item.name LIKE `Fo%`;  
```
###### Явные соединения
```
    SELECT i FROM Item i JOIN i.bids b where b.amount > 100;  
```
- Условием соединения таблиц необязательно должен быть FK, там может быть условие по любым полям;
#### QueryHints стр 417
- Подсказки можно использовать и для `@NamedQuery`
- самые полезные: 
    - _readOnly_ включает или отключает механизм `DirtyChecking`;
    - _flushMode_ указывает, нужно ли выталкивать изменения в БД перед выполнением запроса;
    - _fetchSize_ hint для базы данных, указывает количество одновременно извлекаемых записей;
### Всячина
- от аннотации `@Id` зависит то, как будет получен доступ к полям, через методы доступа(если `@Id` над методом) или напрямую к полям(если `@Id` над полем);
- JPA аннотации нельзя вешать на уровне пакета(в фале `package-info.java`). Если сильно нужно, юзайте Хибернейтовские аналоги. 
- Валидационные аннотации на энтити участвуют в генерации схемы. 
- Доступ к полям Энтити для валидации можно настраивать отдельно от остального хибернейта, через метод или напрямую к полю;
- `hydration` - преобразование `ResultSet` в массив значений.  `hydrated state` сохраняется в текущий context внутри `EntityEntry` и содержит состояние энтити на момент загрузки. Нужно для:
    - работы `dirty checking` механизма;
    - `second-level cache`, записи в котором формируются из `hydrated state`;
- `dehydration` операция обратная `hydration`, копирует состояние энтити в _INSERT_ или _UPDATE_ statementы.
- если поле not null, то желательно ставить и `@NotNull` аннотацию, чтобы можно было проверить вручную при необходимости.
- Аннотации бесмысленно вешать над setteraми
- `@ColumnTransformer` почти как `@Formula`, но он даёт возможность для записи. Можно использовать для шифрования/дешифрования или конвертации чего-то.
- `@Generated` помечает автогенерируемое поле и значит, что Hiber сразу после INSERT или UPDATE сделает select, чтобы узнать сгенерированное значение.
- Без или с пустой `@Enumerated` Хибер  будет сохранять ordinal значение Энама. 
- `@Converter` не работает с `@Enumerated` и `@Temporal`
- @Nationalized — позволяет явно управлять выбором кодировки и менять типы столбцов на `NCHAR`, `NVARCHAR` или `NCLOB`.
- `@Type` позволяет выбрать адаптер.  `@Type(type = "yes_no")`
- Если каскад в БД удаляет все связи, то нужно что-то придумывать, чтобы синхронизировать состояния БД и прилаге + в кэше второго уровня. 
К тому же `@PreRemove` не сработает, т.к. хибер ничего не знает про удаление каскадом в БД. Короче, Лучше не юзать каскад в БД.
- RЕсли объявить энтитю неизменяемой(`@Immutable`) nто хибер может применить оптимизации, например не проверять состояние энтити(_Dirty checking_ ?) при коммите.
- `@Check` позволяет задавать кастомные ограничения, которые применятся при автогенерации схемы.
- Через `@JoinColumn(referencedColumnName = "..."")` можно указать конкретную колонку, на которую будет указывать FK, т.е. это не обязательно PK;
- `PersistentUnitUtil#isLoaded` позволяет определить, является ли объект полноценным или _Proxy_;
- Вызов любого метода кроме метода возвращаещего ID (getId) тригернёт запрос к базе данных;
- Если во время инициализации прокси объекта нужной записи в базе данных не окажется, вылетит исключение `EntityNotFoundException`;
- `Hibernate.initialize()` позволяет вручную загрузить _Proxy_ объект;
- При обращении к прокси объекту вне транзакции, будет выброшено `LazyInitializationException`;
- Можно сбросить объекту id после удаления с помощью параметра `hibernate.use_identifier_rollback = true`. Нужно для того, чтобы удалённый объект можно было сохранить в качестве нового.
- чтобы удалить _detached_ объект, перед удалением нужно сделать _merge_

